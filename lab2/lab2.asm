title lab1
.686
.model flat, stdcall
option casemap :none ; case sensitive
; Раздел подключения библиотек
 include c:\masm32\include\windows.inc
 include c:\masm32\include\kernel32.inc
 include c:\masm32\include\user32.inc
 include c:\masm32\include\masm32.inc
 include c:\masm32\macros\macros.asm
 includelib c:\masm32\lib\masm32.lib
 includelib c:\masm32\lib\kernel32.lib
 includelib c:\masm32\lib\user32.lib
; Сегмент данных
.data
X dd 87654321h
Y dd ?
Z dd 87654321h
p dd 87654321h
array dd 87654321h
; Сегмент кода
.code
; Точка входа в программу
main proc far

;Пример 2.1 Регистровая адресация
mov EAX, EBX ; копируются данные из EBX в EAX
mov DX, BX ; копируются данные из BX в DX
mov AL, CH ; копируются данные из CH в AL
xchg AL, AH ; обмен значений регистров AL и AH

;Пример 2.2 Непосредственная адресация
; счетчик проинициализировать числом 10
mov ECX, 10
; Поместить в EAX число 10h (16)
mov EAX, 10h
; загрузка адресов в индексный регистр
lea ESI, X
; загрузка адресов в регистр EBX
lea EBX, Y

;Пример 2.3 Прямая адресация
; скопировать в BX слово по адресу ES:00404000
; (Необходимо иметь доступ к данным, расположеннм по этому адресу!
; В противном сучае обращение вызовет исключение.)
mov BX, ES:00404000h
; Если в сегменте, на который указывает DS, есть переменная с именем X
; размером двойное слово, то значение хранящееся в EDX можно сохранить
; в X так:
mov [X], EDX
; или так:
mov X, EDX
; Поместить данные из переменной в регистр:
mov EAX, Z

;Пример 2.4 Косвенная адресация
; пусть в сегменте, на который указывает DS, первым объявлено слово p,
; а следом за ним - слово q; тогда их значения можно скопировать так:
lea EBX, [p] ; Получаем эффективный адрес переменной 
mov AX, [EBX] ; Копируем данные в регистр из яейки с адресом равным EBX
add EBX, 000000002h ; Перемещаемся к следующей ячейке (к переменной q)
mov CX, [EBX] ; Копируем данные в регистр из яейки с адресом равным EBX

;Пример 2.5 Адресация по базе со смещением
; следующие команды из примера 4 можно заменить на одну:
; lea EBX, [p]
; add EBX, 000000002h
; mov CX, [EBX]
mov CX, [EBX + 000000002h]

;Пример 2.6 Адресация по базе с индексированием
; Пусть объявлен массив слов array; тогда получить значения
; первого, третьего и пятого элемента можно так:
mov EBX, offset array
mov ESI, 00000000h
mov AX, [EBX][ESI] ; 1
add ESI, 4
mov AX, [EBX][ESI] ; 3
add ESI, 4
mov AX, [EBX][ESI] ; 5


;Пример 2.7 Временное хранение данных
push EAX ; сохраняем текущее значение EAX в стеке
 ; выполняем какие нибудь действия, 
 ; использующие EAX
pop EAX ; восстанавливаем прежнее значение EAX

;Пример 2.8 Копирование содержимого одного сегментного регистра в другой
push DS
pop ES


;Пример 2.9 Выделение старшей части расширенного регистра данных (с помещением значения в другой регистр)
push EAX ; помещаем значение eax в стек (4 байта)
pop AX ; извлекаем младшую часть (2 байта)
pop BX ; извлекаем старшую часть (2 байта)


;Пример 2.10 Извлечение данных из произвольной ячейки стека
mov EBP, ESP
mov AX, [EBP + 2]

;Пример 2.11 Работа с флагами
lahf ; загружаем в ah содержимое флагового регистра
stc ; устанавливаем флаг cf
clc ; сбрасываем флаг cf
cmc ; инвертируем флаг cf
std ; устанавливаем флаг df
cld ; сбрасываем флаг df
cli ; сбрасываем флаг if
sti ; устанавливаем флаг if
sahf ; восстанавливаем из ah флаговый регистр


 invoke ExitProcess, EAX
main endp
; Конец программы
end main